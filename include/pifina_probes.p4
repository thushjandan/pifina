/**
* PIFINA P4 Probes
*
* Copyright 2023 Thushjandan Ponnudurai

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// Initialize pifina meta data fields to default values.
#define pifina_ig_parser_init(meta) meta = {false, 0}
#define pifina_eg_parser_init(meta) meta = {false, 0, 0}

/**
* Egress parser to extract data from temporary pifina control header.
*/
parser PifinaEgressParser(packet_in packet, inout pf_egress_metadata_t meta) {
    pf_control_t pfControlHeader;

    state start {
        packet.extract(pfControlHeader);

        meta.pfIsMatch = pfControlHeader.pfIsMatch;
        meta.pfSessionId = pfControlHeader.pfSessionId;
        pfControlHeader.setInvalid();
        meta.pfPacketLength = 0;
        transition accept;
    }
}

/**
* Pifina Ingress Start probe
*/
control PfIngressStartProbe(in ingress_headers_t hdr, inout pf_ingress_metadata_t meta) {
    // Counter attached to Match action. 
    // Spec: 2 entries per RAM word, 28 bit packet counter width & 36 bit byte counter width
    DirectCounter<bit<36>>(CounterType_t.PACKETS_AND_BYTES) pfIngressStartCounter;

    // Header byte counter before TM
    @name("PF_INGRESS_START_HDR_SIZE")
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfIngressStartByteRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfIngressStartByteRegister) pfIngressStartByteRegisterAction = {
        void apply(inout bit<32> byteCount) {
            // Increment counter by packet header size
            byteCount = byteCount + sizeInBytes(hdr);
        }
    };

    // sessionId is a number from 0-127 as table contains only 128 entries. Needs to be unique.
    action pf_start_ingress_measure(pf_stats_width_t sessionId) {
        // Trigger direct counter
        pfIngressStartCounter.count();
        // Flag the packet for further processing.
        meta.pfIsMatch = true;
        meta.pfSessionId = sessionId;
        // Trigger header size counter
        pfIngressStartByteRegisterAction.execute(sessionId);
    }

    @name("PF_INGRESS_MATCH_CNT")
    table pf_ig_start_selector {
        // Keys are dynamically generated by pifina-cli
        key = {
            hdr.ipv4.protocol: exact;
            hdr.ipv4.dstAddr: ternary;
            hdr.ipv4.srcAddr: ternary;
            
        }
        actions = {
            pf_start_ingress_measure;
        }
        // Attach direct packet and byte counter
        counters = pfIngressStartCounter;
        size = PF_TABLE_SIZE;
    }

    apply {
        // Start Ingress measurement
        pf_ig_start_selector.apply();
    }
}

/**
* Pifina Ingress End probe
*/
control PfIngressEndProbe(inout ingress_headers_t hdr, in pf_ingress_metadata_t meta, in ingress_intrinsic_metadata_t ig_intr_md) {
    // Header byte counter BEFORE deparser
    @name("PF_INGRESS_END_HDR_SIZE")
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfIngressEndByteRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfIngressEndByteRegister) pfIngressEndByteRegisterAction = {
        void apply(inout bit<32> byteCount) {
            // Increment counter by packet header size
            byteCount = byteCount + sizeInBytes(hdr);
        }
    };

    @name("PF_INGRESS_TSTAMP_DIFF_LOW")
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfIngressJitterLowRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfIngressJitterLowRegister) pfIngressJitterLowRegisterAction = {
        void apply(inout bit<32> tstamp) {
            // Increment counter by packet header size
            tstamp = ig_intr_md.ingress_mac_tstamp[31:0] - tstamp;
        }
    };
    @name("PF_INGRESS_TSTAMP_DIFF_HIGH")
    Register<bit<16>, pf_stats_width_t>(PF_TABLE_SIZE) pfIngressJitterHighRegister; 
    RegisterAction<bit<16>, pf_stats_width_t, void>(pfIngressJitterHighRegister) pfIngressJitterHighRegisterAction = {
        void apply(inout bit<16> tstamp) {
            // Increment counter by packet header size
            tstamp = ig_intr_md.ingress_mac_tstamp[47:32] - tstamp;
        }
    };

    action pf_end_ingress_measure() {
        pfIngressEndByteRegisterAction.execute(meta.pfSessionId);

        // Bridge metadata to egress pipeline
        hdr.pfControl.setValid();
        hdr.pfControl.pfIsMatch = meta.pfIsMatch;
        hdr.pfControl.pfSessionId = meta.pfSessionId;
    }

    action pf_measure_jitter_low() {
        pfIngressJitterLowRegisterAction.execute(meta.pfSessionId);
    }

    action pf_measure_jitter_high() {
        pfIngressJitterHighRegisterAction.execute(meta.pfSessionId);
    }

    apply {
        // LAST Operation
        // End Ingress measurement.
        if (meta.pfIsMatch == true) {
            pf_end_ingress_measure();
            pf_measure_jitter_low();
            pf_measure_jitter_high();
        }
    }
}

/**
* Pifina Egress Start probe
*/
control PfEgressStartProbe(in egress_headers_t hdr, inout pf_egress_metadata_t meta, in egress_intrinsic_metadata_t eg_intr_md) {
    // Spec: 2 entries per RAM word, 28 bit packet counter width & 36 bit byte counter width
    @name("PF_EGRESS_START_CNT")
    Counter<bit<36>, pf_stats_width_t>(PF_TABLE_SIZE, CounterType_t.PACKETS_AND_BYTES) pfEgressStartCounter;

    action pf_start_egress_measure() {
        // Decrement 1 byte overhead from bridge header
        pfEgressStartCounter.count(meta.pfSessionId, 1);
    }
    
    apply {
        if (meta.pfIsMatch == true) {
            // Calculate packet payload size for later uses.
            meta.pfPacketLength = (bit<32>) eg_intr_md.pkt_length - sizeInBytes(hdr);
            pf_start_egress_measure();
        }
    }
}

/**
* Pifina Egress End probe
*/
control PfEgressEndProbe(in egress_headers_t hdr, inout pf_egress_metadata_t meta) {
    // Header byte counter BEFORE deparser
    @name("PF_EGRESS_END_CNT")
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfEgressEndByteRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfEgressEndByteRegister) pfEgressEndByteRegisterAction = {
        void apply(inout bit<32> byteCount) {
            byteCount = byteCount + meta.pfPacketLength;
        }
    };

    action pf_end_egress_measure() {
        pfEgressEndByteRegisterAction.execute(meta.pfSessionId);
    }
    
    apply {
        if (meta.pfIsMatch == true) {
            // Add current packet header size
            meta.pfPacketLength = meta.pfPacketLength + sizeInBytes(hdr);
            pf_end_egress_measure();
        }
    }
}
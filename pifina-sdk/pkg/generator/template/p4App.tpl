/**
* THIS FILE HAS BEEN GENERATED BY pifina-cli.
* PIFINA P4 Probes
*
* Copyright 2023 Thushjandan Ponnudurai

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// Initialize pifina meta data fields to default values.
#define pifina_ig_parser_init(meta) meta = {{"{{"}}false, 0}, 0, 0}
#define pifina_eg_parser_init(packet,meta) meta = {{"{{"}}false, 0}, 0}; \
                                    packet.extract(meta.pfControl)

/**
* Pifina Ingress Start probe
*/
control PfIngressStartProbe(in {{ .IngressHeaderType }} hdr, inout pf_ingress_metadata_t meta) {
    // Counter attached to Match action. 
    // Spec: 2 entries per RAM word, 28 bit packet counter width & 36 bit byte counter width
    DirectCounter<bit<36>>(CounterType_t.PACKETS_AND_BYTES) pfIngressStartCounter;

    // Header byte counter before TM
    @name("PF_INGRESS_START_HDR_SIZE")
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfIngressStartByteRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfIngressStartByteRegister) pfIngressStartByteRegisterAction = {
        void apply(inout bit<32> byteCount) {
            // Increment counter by packet header size
            byteCount = byteCount + sizeInBytes(hdr);
        }
    };

    // sessionId is a number from 0-127 as table contains only 128 entries. Needs to be unique.
    action pf_start_ingress_measure(pf_stats_width_t sessionId) {
        // Trigger direct counter
        pfIngressStartCounter.count();
        // Flag the packet for further processing.
        meta.pfControl.setValid();
        meta.pfControl.pfIsMatch = true;
        meta.pfControl.pfSessionId = sessionId;
        // Trigger header size counter
        pfIngressStartByteRegisterAction.execute(sessionId);
    }

    @name("PF_INGRESS_MATCH_CNT")
    table pf_ig_start_selector {
        // Keys are dynamically generated by pifina-cli
        key = {
            {{ range .MatchKeys }}{{ .Name }}: {{ .MatchType }};
            {{end}}
        }
        actions = {
            pf_start_ingress_measure;
        }
        // Attach direct packet and byte counter
        counters = pfIngressStartCounter;
        size = PF_TABLE_SIZE;
    }

    apply {
        // Start Ingress measurement
        pf_ig_start_selector.apply();
    }
}

/**
* Pifina Ingress End probe
*/
control PfIngressEndProbe(inout {{ .IngressHeaderType }} hdr, inout pf_ingress_metadata_t meta, in ingress_intrinsic_metadata_t ig_intr_md) {
    // Header byte counter BEFORE deparser
    @name("PF_INGRESS_END_HDR_SIZE")
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfIngressEndByteRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfIngressEndByteRegister) pfIngressEndByteRegisterAction = {
        void apply(inout bit<32> byteCount) {
            // Increment counter by packet header size
            byteCount = byteCount + sizeInBytes(hdr);
        }
    };

    // Store current timestamp for later latency computation.
    Register<bit<64>, pf_stats_width_t>(PF_TABLE_SIZE) pfPreviousTstamp; 
    RegisterAction<bit<64>, pf_stats_width_t, bit<48>>(pfPreviousTstamp) pfPreviousTstampAction = {
        void apply(inout bit<64> tstamp, out bit<48> result) {
            // Compute latency between current packet and the previous packet
            result = ig_intr_md.ingress_mac_tstamp - tstamp[47:0];
            // Store current timestamp with a padding
            tstamp = 16w0 ++ ig_intr_md.ingress_mac_tstamp;
        }
    };

    @name("PF_INGRESS_JITTER_AVG")
    Register<bit<64>, pf_stats_width_t>(PF_TABLE_SIZE) pfJitterRegister; 
    RegisterAction<bit<64>, pf_stats_width_t, void>(pfJitterRegister) pfJitterRegisterAction = {
        void apply(inout bit<64> value) {
            // Store current jitter with a padding
            value = 16w0 ++ meta.pfJitter;
        }
    };

    // Initialize Low pass filter for computing exponential moving average.
    @name("PF_INGRESS_JITTER_LPF")
    Lpf<bit<48>, pf_stats_width_t>(PF_TABLE_SIZE) pfIngressJitterLpf;

    action pf_end_ingress_measure() {
        pfIngressEndByteRegisterAction.execute(meta.pfControl.pfSessionId);
    }

    // approx. compute exponential moving average with help of low pass filter
    action pf_calc_moving_average() {
        meta.pfJitter = pfIngressJitterLpf.execute(meta.pfArrivalLatency, meta.pfControl.pfSessionId);
    }

    action pf_store_jitter() {
        pfJitterRegisterAction.execute(meta.pfControl.pfSessionId);
    }

    apply {
        // LAST Operation
        // End Ingress measurement.
        if (meta.pfControl.pfIsMatch == true) {
            pf_end_ingress_measure();
            // Compute latency and store current timestamp
            meta.pfArrivalLatency = pfPreviousTstampAction.execute(meta.pfControl.pfSessionId);
            // Compute moving average over LPF unit
            pf_calc_moving_average();
            // Store computed jitter value in register
            pf_store_jitter();
        }
    }
}

/**
* Pifina Egress Start probe
*/
control PfEgressStartProbe(in {{ .EgressHeaderType }} hdr, inout pf_egress_metadata_t meta, in egress_intrinsic_metadata_t eg_intr_md) {
    // Spec: 2 entries per RAM word, 28 bit packet counter width & 36 bit byte counter width
    @name("PF_EGRESS_START_CNT")
    Counter<bit<36>, pf_stats_width_t>(PF_TABLE_SIZE, CounterType_t.PACKETS_AND_BYTES) pfEgressStartCounter;

    action pf_start_egress_measure() {
        // Decrement 1 byte overhead from bridge header
        pfEgressStartCounter.count(meta.pfControl.pfSessionId, 1);
    }
    
    apply {
        if (meta.pfControl.pfIsMatch == true) {
            // Calculate packet payload size for later uses.
            meta.pfPacketLength = (bit<32>) eg_intr_md.pkt_length - sizeInBytes(hdr);
            pf_start_egress_measure();
        }
    }
}

/**
* Pifina Egress End probe
*/
control PfEgressEndProbe(in {{ .EgressHeaderType }} hdr, inout pf_egress_metadata_t meta) {
    // Header byte counter BEFORE deparser
    @name("PF_EGRESS_END_CNT")
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfEgressEndByteRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfEgressEndByteRegister) pfEgressEndByteRegisterAction = {
        void apply(inout bit<32> byteCount) {
            byteCount = byteCount + meta.pfPacketLength;
        }
    };

    action pf_end_egress_measure() {
        pfEgressEndByteRegisterAction.execute(meta.pfControl.pfSessionId);
    }
    
    apply {
        if (meta.pfControl.pfIsMatch == true) {
            // Add current packet header size
            meta.pfPacketLength = meta.pfPacketLength + sizeInBytes(hdr);
            pf_end_egress_measure();
        }
    }
}
{{ range .ExtraProbeList }}
/**
* Pifina {{ .Type }} Extra probe {{ .Name }}
*/
{{- if eq .Type "INGRESS" }}
control PfIngressExtraProbe{{ .Name }}(in {{ $.IngressHeaderType }} hdr, in pf_ingress_metadata_t meta) {
    // Header byte counter BEFORE deparser
    @name("PF_INGRESS_EXTRA_{{ .Name }}")
{{- else }}
control PfEgressExtraProbe{{ .Name }}(in {{ $.EgressHeaderType }} hdr, in pf_egress_metadata_t meta) {
    // Header byte counter BEFORE deparser
    @name("PF_EGRESS_EXTRA_{{ .Name }}")
{{- end }}
    Register<bit<32>, pf_stats_width_t>(PF_TABLE_SIZE) pfHdrByteRegister; 
    RegisterAction<bit<32>, pf_stats_width_t, void>(pfHdrByteRegister) pfHdrByteRegisterAction = {
        void apply(inout bit<32> byteCount) {
            byteCount = byteCount + sizeInBytes(hdr);
        }
    };

    action pf_extra_measure() {
        pfHdrByteRegisterAction.execute(meta.pfControl.pfSessionId);
    }
    
    apply {
        if (meta.pfControl.pfIsMatch == true) {
            pf_extra_measure();
        }
    }
}
{{end}}